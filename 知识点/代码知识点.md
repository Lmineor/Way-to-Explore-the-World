## 第一章 绪论
## 第2章 线性表
### 2.2.1 顺序表的定义
线性表的顺序存储类型描述为：

* 1、静态分配描述
```
#define MaxSize 50              //定义线性表的最大长度
typedef struct{
    ElemType data[MaxSize];     // 顺序表的元素
    int length;                 // 顺序表的当前长度
}SqList;                        //顺序表的类型定义
```
* 2、动态分配描述
```
#define InitSize 100            //表长度的初始定义
typedef struct{
    ElemType *data;             //指示动态分配数组的指针
    int MaxSize,length;         //数组的最大容量和当前个数
}SqList;                        //动态分配数组顺序表的类型定义
```
C的初始动态分配语句为：
```
L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);
```
### 2.2.2 顺序表上基本操作的实现
(1) 插入操作
```c
bool ListInsert(SqList &L, int i ,ElemType e){
    //本算法实现将元素e插入到顺序表L中第i个位置
    if(i<1||i>L.length+1)           //判断i的范围是否有效
        return false;
    if(L.length>=MaxSize)           //当前存储空间已满，不能插入
        return false;
    for(int j=L.length;j>i;j--)     //将第i个元素及之后的元素后移
      L.data[j]=L.data[j-1];
    L.data[i-1]=e;                  //在位置i处放入e
    L.length++;                     //线性表长度加1
    return true;
}
```
线性表插入算法的平均时间复杂度为O(n)

(2)删除操作
```c
bool ListDelete(SqList &L, int i, Elemtype &e){
    //本算法实现删除顺序表L中第i个位置的元素
    if(i<1||i>L.length+1)           //判断i的范围是否有效
        return false;
    e=L.data[i-1];                  //将被删除的元素赋值给e
    for(int j=i;j<L.length;j++)     //将第i个位置之后的元素前移
        L.data[j-1]=L.data[j];
    L.length--;                     //线性表长度减1
    return true;
}
```
线性表删除算法的平均时间复杂度为O(n)

(3)按值查找（顺序查找）
```c
int LocateElem(SqList L, ElemType e){
    //本算法实现查找顺序表中值为e的元素，如果查找成功，返回元素位序，否则返回0
    int i;
    for(i=0;i<L.length;i++)
        if(L.data[i]==3)
            return i+1;             //下表为i的元素值等于e，返回其位序i+1
    return 0;
}
```
线性表按值查找算法的平均时间复杂度为O(n).
## 2.3 线性表的链式表示
### 2.3.1 单链表的定义
单链表中结点类型的描述如下：
```c
typedef struct LNode{       //定义单链表结点类型
    ElemType data;          //数据域
    struct LNode *next;     //指针域
}LNode, *LinkList;
```
### 2.3.2 单链表上基本操作的实现
1、采用头插法建立单链表
```c
LinkList CreatList1(LinkList &L){
    //从表尾到表头逆向建立单链表L,每次均在头结点之后插入元素
    LNode *s;int x;
    L = (LinkList)malloc(sizeof(LNode));        //创建头结点
    L->next = NULL;                             //初始为空链表
    scanf("%d",&x);                             //输入结点的值
    while(x!=9999){                             //输入9999表示结束
        s = (LNode*)malloc(sizeof(LNode));      //创建新的结点
        s->data = x;
        s->next=L->next;
        L->next=s;                              //将新结点插入表中，L为头指针
        scanf("%d",&x);
    }                                           //while结束
    return L;
}
```
2、采用尾插法建立单链表
```c
LinkList CreatList2(LinkList &L){
    //从表头到表尾正向建立单链表L，每次均在表尾插入元素
    int x;                                      //设元素类型为整型
    L = (LinkList)malloc(sizeof(LNode));
    LNode *s,*r = L;                            //r为表尾指针
    scanf("%d",&x);                             //输入结点的值
    while(x!=9999){                             //输入9999表示结束
        s = (LNode*)malloc(sizeof(LNode));
        s->data = x;
        r->next = s;
        r = s;                                  //r指向新的表尾结点
        scanf("%d",&x);
    }
    r->next = NULL;                             //尾指针置空
    return L;
}
```
3、按序号查找结点值
```c
LNode *GetElem(LinkList L,int i){
    //本算法取出单链表L（带头结点）中第i个位置的结点指针
    int j = i;                                 //计数，初始为1
    LNode *p = L->next                         //头结点指针赋给p
    if(i==0)
        return L;                               //若i等于0，则返回头结点
    if(i<1)
        return NULL;                            //若i无效，则返回NULL
    while(p&&j<i){                              //从第1个结点开始找，查找第i个结点
        p = p->next;
        j++;
    }
    return p;                                   //返回第i个结点的指针，如果i大于表长，p=NULL，直接返回p即可
}
```
4、按值查找表结点
```c
LNode *LocateElem(LinkList L, ElemType e){
    //本算法查找单链表L（带头结点）中数据域值等于e的结点指针，否则返回NULL
    LNode *p = L->next;
    while(p!=NULL&&p->data!=e)                  //从第1个结点开始朝赵data域为e的结点
        p = p->next;
    return p;                                   //找到后返回该结点的指针，否则返回NULL
}
```
5、插入结点操作
实现插入结点的代码片段如下：
```c
p = GetElem(L,i-1);                             //查找插入位置的前驱结点
s->next = p->next;
p->next = s;
```
6、删除结点操作
代码片段
```
p = GetElem(L,i-1);                         //查找删除位置的前驱结点
q = p->next;                                //令q指向被删除结点
p->next = q->next;                          //将*q结点从链中“断开”
free(q);                                    //释放结点的存储空间
```