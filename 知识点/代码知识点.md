# 数据结构相关代码片段
## 第一章 绪论
## 第2章 线性表
### 2.2.1 顺序表的定义
线性表的顺序存储类型描述为：

* 1、静态分配描述
```c
#define MaxSize 50              //定义线性表的最大长度
typedef struct{
    ElemType data[MaxSize];     // 顺序表的元素
    int length;                 // 顺序表的当前长度
}SqList;                        //顺序表的类型定义
```
* 2、动态分配描述
```c
#define InitSize 100            //表长度的初始定义
typedef struct{
    ElemType *data;             //指示动态分配数组的指针
    int MaxSize,length;         //数组的最大容量和当前个数
}SqList;                        //动态分配数组顺序表的类型定义
```
C的初始动态分配语句为：
```c
L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);
```
### 2.2.2 顺序表上基本操作的实现
(1) 插入操作
```c
bool ListInsert(SqList &L, int i ,ElemType e){
    //本算法实现将元素e插入到顺序表L中第i个位置
    if(i<1||i>L.length+1)           //判断i的范围是否有效
        return false;
    if(L.length>=MaxSize)           //当前存储空间已满，不能插入
        return false;
    for(int j=L.length;j>i;j--)     //将第i个元素及之后的元素后移
      L.data[j]=L.data[j-1];
    L.data[i-1]=e;                  //在位置i处放入e
    L.length++;                     //线性表长度加1
    return true;
}
```
线性表插入算法的平均时间复杂度为O(n)

(2)删除操作
```c
bool ListDelete(SqList &L, int i, Elemtype &e){
    //本算法实现删除顺序表L中第i个位置的元素
    if(i<1||i>L.length+1)           //判断i的范围是否有效
        return false;
    e=L.data[i-1];                  //将被删除的元素赋值给e
    for(int j=i;j<L.length;j++)     //将第i个位置之后的元素前移
        L.data[j-1]=L.data[j];
    L.length--;                     //线性表长度减1
    return true;
}
```
线性表删除算法的平均时间复杂度为O(n)

(3)按值查找（顺序查找）
```c
int LocateElem(SqList L, ElemType e){
    //本算法实现查找顺序表中值为e的元素，如果查找成功，返回元素位序，否则返回0
    int i;
    for(i=0;i<L.length;i++)
        if(L.data[i]==3)
            return i+1;             //下表为i的元素值等于e，返回其位序i+1
    return 0;
}
```
线性表按值查找算法的平均时间复杂度为O(n).
## 2.3 线性表的链式表示
### 2.3.1 单链表的定义
单链表中结点类型的描述如下：
```c
typedef struct LNode{       //定义单链表结点类型
    ElemType data;          //数据域
    struct LNode *next;     //指针域
}LNode, *LinkList;
```
### 2.3.2 单链表上基本操作的实现
1、采用头插法建立单链表
```c
LinkList CreatList1(LinkList &L){
    //从表尾到表头逆向建立单链表L,每次均在头结点之后插入元素
    LNode *s;int x;
    L = (LinkList)malloc(sizeof(LNode));        //创建头结点
    L->next = NULL;                             //初始为空链表
    scanf("%d",&x);                             //输入结点的值
    while(x!=9999){                             //输入9999表示结束
        s = (LNode*)malloc(sizeof(LNode));      //创建新的结点
        s->data = x;
        s->next=L->next;
        L->next=s;                              //将新结点插入表中，L为头指针
        scanf("%d",&x);
    }                                           //while结束
    return L;
}
```
2、采用尾插法建立单链表
```c
LinkList CreatList2(LinkList &L){
    //从表头到表尾正向建立单链表L，每次均在表尾插入元素
    int x;                                      //设元素类型为整型
    L = (LinkList)malloc(sizeof(LNode));
    LNode *s,*r = L;                            //r为表尾指针
    scanf("%d",&x);                             //输入结点的值
    while(x!=9999){                             //输入9999表示结束
        s = (LNode*)malloc(sizeof(LNode));
        s->data = x;
        r->next = s;
        r = s;                                  //r指向新的表尾结点
        scanf("%d",&x);
    }
    r->next = NULL;                             //尾指针置空
    return L;
}
```
3、按序号查找结点值
```c
LNode *GetElem(LinkList L,int i){
    //本算法取出单链表L（带头结点）中第i个位置的结点指针
    int j = i;                                 //计数，初始为1
    LNode *p = L->next                         //头结点指针赋给p
    if(i==0)
        return L;                               //若i等于0，则返回头结点
    if(i<1)
        return NULL;                            //若i无效，则返回NULL
    while(p&&j<i){                              //从第1个结点开始找，查找第i个结点
        p = p->next;
        j++;
    }
    return p;                                   //返回第i个结点的指针，如果i大于表长，p=NULL，直接返回p即可
}
```
4、按值查找表结点
```c
LNode *LocateElem(LinkList L, ElemType e){
    //本算法查找单链表L（带头结点）中数据域值等于e的结点指针，否则返回NULL
    LNode *p = L->next;
    while(p!=NULL&&p->data!=e)                  //从第1个结点开始朝赵data域为e的结点
        p = p->next;
    return p;                                   //找到后返回该结点的指针，否则返回NULL
}
```
5、插入结点操作
实现插入结点的代码片段如下：
```c
p = GetElem(L,i-1);                             //查找插入位置的前驱结点
s->next = p->next;
p->next = s;
```
6、删除结点操作
代码片段
```
p = GetElem(L,i-1);                         //查找删除位置的前驱结点
q = p->next;                                //令q指向被删除结点
p->next = q->next;                          //将*q结点从链中“断开”
free(q);                                    //释放结点的存储空间
```
时间复杂度为O(n)

### 2.3.3 双链表
双链表中结点类型的描述为：
```c
typdef struct DNode{                        //定义双链表结点类型
    EleType data;                           //数据域
    struct DNode *prior,*next;              //前驱和后继指针
}DNode, *DLinklist;
```
1、双链表的插入操作
代码片段为：
```c
s->next = p->next;                          //将结点*s插入到结点*p之后
p->next->prior = s;
s->prior = p;
p->next = s;
```
2、双链表的删除操作
```c
p->next = q->next;
q->next->prior = p;
free(q);                                    //释放结点空间
```
### 2.3.4 循环链表
### 2.3.5 静态链表
静态链表结构类型的描述为：
```c
#define MaxSize 50;                         //静态链表的最大长度
typedef struct{                             //静态链表结构类型的定义
    ElemType data;                          //存储数据元素
    int next;                               //下一个的元素的数组下标
}SlinkList[MaxSize];
```
** 静态链表以 next=-1作为结束标志。**
### 2.3.6 顺序表和链表的比较

#第3章 栈和队列
## 3.1 栈
### 3.1.1 栈的基本概念
### 3.1.2 栈的顺序存储结构
1、顺序栈的实现
栈的书序存储类型描述如下：
```c
#define MaxSize 50;                         //定义栈中元素的最大个数
typedef struct{
    ElemType data[MaxSize];                 //存放栈中元素
    int top;                                //栈顶指针
}SqlStack;
```
2、顺序栈的基本运算
（1）初始化
```c
void InitStack(&S){
    s.top = -1;                             //初始化栈顶指针
}
```
(2) 判栈空
```c
bool StackEmpty(S){
    if(S.top==-1)                           //栈空
        return true;
    else
        return false;                       //不空
}
```
（3）进栈
```c
bool Push(SqStack &S,ElemType x){
    if(S.top==MaxSize-1)                    //栈满，报错
        return false;
    S.data[++S.top] = x;                    //指针先加1，再入栈
    return true;
}
```
（4）出栈
```c
bool Pop(SqStack &S,EleType &x){
    if(S.top ==-1)                          //栈空，报错
        return false;
    x = S.data[S.top--];                    //pop stack first and then point-1
    return true;
}
```
(5)读栈顶元素
```c
bool GetTop(SqStack S,ElemType &x){
    if(S.top ==1)           //empty stack,return error
        return false;
    x = S.data[S.top];          //record top elem of stack with x
    return true;
}
```

### 3.1.3 栈的链式存储结构
栈的链式存储类型描述为
```c
typedef struct LinkNode{
    ElemType data;                  //domain of data
    struct LinkNode *next;          //domain of point
} *LiStack;                         //define of stack
```
## 3.2 队列
1、队列的顺序存储

队列的顺序存储类型可描述为
```c
#define MaxSize 50;                 //define max num of queue
typdef struct{
    int front, rear;                //the front and rear point of stack
}SqQueue;
```

**初始状态（队空条件）:** Q.front = Q.rear = 0

**进队操作：** 队不满时，先送值到队尾元素，再将队尾指针加1

**出队操作：** 队不空时，先取队头元素值，再将对头指针加1

1、循环队列

**初始时：** Q.front = Q.rear = 0;

**队首指针进1：** Q.front = (Q.front+1)%MaxSize

**队尾指针进1：** Q.rear = (Q.rear+1)%MaxSize

**队列长度：** (Q.rear+MaxSize-Q.front)%MaxSize

判断队空与队满

1)、牺牲一个单元来区分队空与队满

**队满条件为：** (Q.rear+1)%MaxSize == Q.front

**队空条件仍为：** Q.front == Q.rear

**队列中元素的个数：** (Q.rear-Q.front+MaxSize)
%MaxSize

2）、类型中增设表示元素个数的数据成员
**队空的条件为：** Q.size == 0
**队满的条件为：** Q.Size == MaxSize
3）、类型中增设tag数据成员，以区分队满还是队空。
**tag = 0 时：** 若因删除导致 Q.front == Q.rear 则为队空
**tag = 1 时：** 若因插入导致 Q.front == Q.rear 则为队满
3.循环队列的操作
(1) 初始化
```c
void InitQueue(&Q){
    Q.rear = Q.front = 0;                           //init the front and rear point of queue
}
```
(2) 判队空
```c
bool isEmpty(Q){
    if(Q.rear == Q) return true;                    //the condition of empty of queue
    else return false;
}
```
(3) 入队
```c
bool EnQueue(SqQueue &Q,ElemType x){
    if((Q.rear+1)%MaxSize==Q.front) return false;   //the queue is not empty
    Q.data[Q.rear] = x;
    Q.rear = (Q.rear+1)%MaxSize;                    //the point of rear +1 and then mod the result
    return true;
}
```
(4) 出队
```bool DeQueue(SqQueue & Q,ElemType &x){
    if(Q.rear==Q.front) return false;               //empty queue,then return false
    x = Q.data[Q.front];
    Q.front = (Q.fornt+1)%MaxSize;                  //the point of front +1 and then mod the result
    return true;
}
```

### 3.2.3 队列的链式存储结构

1、队列的链式存储
队列的链式存储类型描述为
```c
typedef struct{                              //the node of link's queue
    ElemType data;
    struct LinkNode;
}LinkNode;
typedef struct{                             //LinkNode
    LinkNode *front,*rear;                  //the front point and rear point of queue
}LinkQueue;
当Q.front == NULL且Q.rear == NULL ,链式队列为空。
```
2、链式队列的基本操作
（1）、初始化
```c
void InitQueue(LinkQueue &Q){
    Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));                             //create front node
    Q.front ->next = NULL;                  //empty when init
}
```
(2) 判对空
```c
bool IsEmpty(LinkQueue Q){
    if(Q.front ==Q.rear) return true;
    else return false;
}
```
(3) 入队
```c
void Enqueue(LinkQueue &Q,ElemType x){
    s = (LinkNode*)malloc(sizeof(LinkNode));
    s->data = x;s->next = NULL;             //create new node,then insert to end
    Q.rear->next = s;
    Q.rear = s;
}
```
(4) 出队
```c
bool DeQueue(LinkQueue &Q,ElemType &x){
    if(Q.front=Q.rear) return false;            //empty of queue
    p = Q.front->next;
    x = p->data;
    Q.front->next = p->next;
    if(Q.rear == p)
        Q.rear = Q.front;                   //若原队列中只有一个结点，删除后变空
    free(p);
    return true;
}
```
### 3.2.4 双端队列
## 栈和队列的应用
### 3.3.1 栈在括号匹配中的应用
### 3.3.2 栈在表达式求值中的应用
### 3.3.3 栈在递归中的应用
```c
int Fib(n){                             //斐波那契数列的实现
    if(n==0)
        return 0;                       //边界条件
    else if(n==1)
        return 1;                       //边界条件
    else
        return Fib(n-1)+Fib(n-2)        //递归表达式
}
```
- 递归表达式（递归体）
- 边界条件（递归出口）
### 3.3.4 队列在层次遍历中的应用
### 3.3.5 队列在计算机系统中的应用
## 3.4 特殊矩阵的压缩存储
### 3.4.1 数组的定义
### 3.4.2 数组的存储结构
### 3.4.3 矩阵的压缩存储
1、对称矩阵
2、三角矩阵
### 3.4.4 稀疏矩阵

## 第4章 树和二叉树
知识框架
>树形结构
>>二叉树
>>>概念：定义、存储结构
>>>操作
>>>>三种遍历
>>>>搜索二叉树
>>>应用
>>>>排序二叉树--平衡二叉树
>>>>哈夫曼树
>>树和森林
>>>概念：定义、存储结构
>>>操作
>>>>与二叉树的转换
>>>>遍历
>>>应用：并查集